'''
이걸 풀려고 몇 시간동안 머리 싸매다가 결국 다른 사람들의 풀이를 보았는데, 핵심은 스택이었다.
탐욕법 알고리즘이라고 나와있긴 했지만 결국 사용해야 하는 자료구조는 스택이었고,
이 문제를 통해 알고리즘 문제를 해결하는데 자료구조가 어떻게 사용되며 왜 중요한지 어렴풋이 감이 잡혔다.

stack 마지막에 들어있는 숫자(stack[-1])와 for문을 돌며 순서가 된(?) 숫자(i)를 비교하여
stack[-1]의 값이 i보다 크거나 같을 때까지 stack에서 마지막 값을 계속 삭제한다.
삭제가 될 때마다 k의 값도 감소시켜 제거해아하는 숫자의 조건을 계속 업데이트 한다.
그리고 i의 값은 무조건 stack의 마지막에 집어넣는다. 어쨌든 다음 순서의 숫자가 더 크면 while문을
통해 제거가 될 것이기 때문에 무조건 삽입해도 문제가 없다.

여기서 마지막 포인트는 if문인 것같다. for문이 계속 돌아가는데, stack[-1]<i이라는 조건이 더 이상
충족되지 않아서(그러니까 stack에 마지막으로 들어온 값이 남은 i들보다 클경우) stack에 계속해서
삽입이 되는데 k의 값은 0이 아닐경우(즉, 제거해야 할 수가 남아있는 경우) 그만큼만 stack에서 잘라내면 된다.
그것을 실행하는 부분이 바로 if k!=0으로 시작하는 구문인 것이다. 
'''
def solution(number, k):
    answer=""
    stack=[number[0]]
    for i in number[1:]:
        while len(stack)>0 and stack[-1]<i and k>0:
            k-=1
            stack.pop()
        stack.append(i)
        
    if k!=0:
        stack=stack[:-k]
        
    return answer.join(stack)
