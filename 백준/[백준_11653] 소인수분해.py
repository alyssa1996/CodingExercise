'''
이 코드도 다른 사람이 쓴 걸 참고한 거였는데, 처음 이 코드를 보고 이해가 안되었던 것은 어떻게
아무 조치 없이 prime+=1을 해도 코드가 돌아가는가 였다. 그래서 생각을 해보니, prime은 2부터
시작해서 2로 안나누어질때까지 계속 2로만 나눈다. 그러면 당연히 num의 값이 2의 배수들로는
더 이상 나누어질 수 없는 상태가 되어서야 prime 값을 증가시키게 될 것이다. 그렇기 때문에
이 코드가 올바르게 돌아갈 수 있는 것이다. 하지만 이 코드는 무작정 prime의 값을 증가시키기 때문에
시간적인 면에서 비효율 적이다. 소수를 효율적으로 찾아내어 다음 연산을 진행하는 방식이 아니기 때문이다.


*다른 사람들의 풀이를 통해 배운 것들 Remind*
1. 소수는 2를 제외하고 모두 홀수에 해당한다. 그러므로 3이후부터는 prime+=2를 해도 무방하다.
2. 소수를 찾을 때 주로 주어진 n(여기선 num)까지 찾아보는 게 아니라 n의 제곱근까지만 찾는다.
그 이유는 만약 제곱근보다 큰 약수가 있을 경우, 그 약수로 나눈 몫은 제곱근보다 작을 것이기 때문에
그 이전에 이미 나누어보았을 것이기 때문입니다. 
'''

num=int(input(""))

prime=2
while True:
    if num==1:
        break
    if num%prime==0:
        num=num//prime
        print(prime)
    else:
        prime+=1

